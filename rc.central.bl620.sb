//******************************************************************************
// Laird Technologies (c) 2014
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++                                                                      ++
// +++++  When UwTerminal downloads the app it will store it as a filenname   ++
// +++++  which consists of all characters up to the first . and excluding it ++
// +++++                                                                      ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// This app provides for a command interface over the uart and the protocol is
// as follows:-
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Convention : (1) Case sensitive, and commands are presented in alphabetic order
//              (2) If line ends with \ then it continues on next line. That does
//                  not mean that it should be sent as multiple lines
//              (3) Replace anything between ## 
//              (4) #INTaaaa# means a number in decimal, hex, octal or binary
//                      format -> 23 == 0x17 == h'17 == o'23 == b'10111
//                      aaaa is just a description
//              (5) #HEXaaaa# means a string without delimitors consisting of hex 
//                      characters only aaaa is just a description
//              (6) #STRaaaa# means a string without delimitors
//                      aaaa is just a description
//              (7) "STRaaaa" means a string which must have the " delimitor
//                      aaaa is just a description
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// -----------------------------------------------------------------------------
// advert report initadv #INTadflags# #INTadappearance# #INTmaxdevname#
//   - Initialise an advert report and store in string adv$[#INTstridx#]
//   - and populate it with flags AD with value #INTadflags#, apperance AD if
//   - #INTadappearance# is 1 and device name (full or partial) based on the
//   - value of #INTmaxdevname#
//
// -----------------------------------------------------------------------------
// advert report initscn #INTstridx#
//   - Initialise an advert scan report and store in string adv$[#INTstridx#]
//
// -----------------------------------------------------------------------------
// advert report ADuuid16 #INTstridx# #INTuuid0# #INTuuid1# #INTuuid2# #INTuuid3# #INTuuid4# #INTuuid5#
//   - Append the advert report idendified by string adv$[#INTstridx#] with 
//   - the service uuid 16 AD element with up to 6 16 bit uuids. If less than 6 uuids
//   - are specified then set 0's and they will not be added
//
// -----------------------------------------------------------------------------
// advert report ADuuid128 #INTstridx# #INTuuidhandleidx#
//   - Append the advert report idendified by string adv$[#INTstridx#] with 
//   - the service uuid 128 AD element and the 128 bit uuid is supplied by a
//   - uuid handle that will have been returned from BleHandleUuid128() or
//   - BleHandleUuidSibling() -- see the 'uuid' commands below
//
// -----------------------------------------------------------------------------
// advert report ADany #INTstridx# #INTtag# #HEXdata$#
//   - Append the advert report idendified by string adv$[#INTstridx#] with 
//   - generic AD element whos tag will be #INTtag# and the data is as
//   - per the data in #HEXdata$# which will be converted from a hx string
//   - into a binary string before submitting to the stack
//
// -----------------------------------------------------------------------------
// advert report commit #INTstridx0# #INTstridx1#
//   - This is used to commit the advert and/or scan report to the stack.
//   - The reports are in string adv$[#INTstridx0#] and adv$[#INTstridx1#]
//   - and if any of them are empty strings, they will not be submitted
//
// -----------------------------------------------------------------------------
// advert undirected #INTintervalms# #INTtimeoutms# #INTfilterpolicy#
//   - Use this to start adverts of type ADV_IND using the parameters specified
//   - #INTfilterpolicy# is 0=Any, 1=Filter Scans, 2= Filer Conns, 3 = Filter both
//   -   basically if #INTfilterpolicy# != 0 then filter is enabled and the whitelist
//   -   is created from the trusted device database.
//
// -----------------------------------------------------------------------------
// advert scan #INTintervalms# #INTtimeoutms# #INTfilterpolicy#
//   - Use this to start adverts of type ADV_SCAN_IND using the parameters specified
//   - #INTfilterpolicy# is 0=Any, 1=Filter Scans, 2= Filer Conns, 3 = Filter both
//   -   basically if #INTfilterpolicy# != 0 then filter is enabled and the whitelist
//   -   is created from the trusted device database.
//
// -----------------------------------------------------------------------------
// advert nonconn #INTintervalms# #INTtimeoutms# #INTfilterpolicy#
//   - Use this to start adverts of type ADV_NONCONN_IND using the parameters specified
//   - #INTfilterpolicy# is 0=Any, 1=Filter Scans, 2= Filer Conns, 3 = Filter both
//   -   basically if #INTfilterpolicy# != 0 then filter is enabled and the whitelist
//   -   is created from the trusted device database.
//
// -----------------------------------------------------------------------------
// advert directed         #INTintervalms# #INTtimeoutms# #INTfilterpolicy# #HEXaddr14Bytes#
//   - Use this to start adverts of type ADV_DIRECT_IND using the parameters specified
//   - and will be directed to the mac address #HEXaddr14Bytes#
//   - #INTfilterpolicy# is 0=Any, 1=Filter Scans, 2= Filer Conns, 3 = Filter both
//   -   basically if #INTfilterpolicy# != 0 then filter is enabled and the whitelist
//   -   is created from the trusted device database.
//
// -----------------------------------------------------------------------------
// advert stop
//   - Use this to stop adverts
//
// -----------------------------------------------------------------------------
// connect #HEXaddr14Bytes# #INTconntimeoutms# #INTminConnIntUs# #INTmaxConnIntUs# #INTsprvsnToutUs#
//   - connect to peripheral with mac address #HEXaddr14Bytes# using parameters speccified
//
// -----------------------------------------------------------------------------
// connect cancel
//   - abort a connection attempt before it the self-timeout
//
// -----------------------------------------------------------------------------
// connect configwr #INTcfgID# #INTvalue#
//   - set connection configuration parameters
//     #INTcfgID# 
//       0    Connect Interval in milliseconds (range 0..10240)
//       1    Connect Window in milliseconds (range 0..10240)
//       2    Slave Latency (0..1000)
//       5    Multi-Link Connection Interval Periodicity (20..200)
//
// -----------------------------------------------------------------------------
// connect configrd #INTcfgID#
//   - get connection configuration parameters
//     #INTcfgID# 
//       0    Connect Interval in milliseconds (range 0..10240)
//       1    Connect Window in milliseconds (range 0..10240)
//       2    Slave Latency (0..1000)
//       5    Multi-Link Connection Interval Periodicity (20..200)
//
// -----------------------------------------------------------------------------
// connect encrypt #INTconnHandle# #INTminKeySize# #INTmitmRequired#
//   - Request the connection to be encrypted
//
// -----------------------------------------------------------------------------
// disconnect #INTconnHandle#
//    - disconnect the connection associated with the handle
//
// -----------------------------------------------------------------------------
// gattc char first #INTconnHandle# #INTuuidHandleIdx# #INTsvcStartAttrHandle# \
//                  #INTsvcEndAttrHandle#
//    --- gatt client functionality ---
//    - Find the first characteristic starting from handle #INTsvcStartAttrHandle# 
//    - in the connection specified by #INTconnHandle# and specify a value of 0 for
//    - #INTuuidHandleIdx# to look for any characteristic, otherwise a uuid handle
//    - that will have been obtained by using the uuid command
//
// -----------------------------------------------------------------------------
// gattc char next #INTconnHandle#
//    --- gatt client functionality ---
//    - After calling 'gattc char first' command and getting a characteristic use
//    - this command to get the next characteristic in the remote server for the 
//    - service that was identified by #INTsvcStartAttrHandle# in the 
//    - 'gatt char first' command
//
// -----------------------------------------------------------------------------
// gattc close
//    --- gatt client functionality ---
//    - Close the gatt client and release heap memory
//
// -----------------------------------------------------------------------------
// gattc desc first #INTconnHandle# #INTuuidHandleIdx# #characteristic#
//    --- gatt client functionality ---
//    - Find the first descriptor for the characteristic whose value handle is
//    - has the handle #INTcharStartAttrHandle# in the connection specified by 
//    - #INTconnHandle# and specify a value of 0 for #INTuuidHandleIdx# to look for 
//    - any descriptor, otherwise a uuid handle that will have been obtained by 
//    - using the uuid command
//
// -----------------------------------------------------------------------------
// gattc desc next #INTconnHandle#
//    --- gatt client functionality ---
//    - After calling 'gattc desc first' command and getting a descriptor use
//    - this command to get the next descriptor in the remote server for the 
//    - characteristic that was identified by #characteristic# in the 
//    - 'gatt desc first' command
//
// -----------------------------------------------------------------------------
// gattc findchar #INTconnHandle# #INTsvcuuidHandleIdx# #INTsvcIndex# \
//                #INTcharuuidHandleIdx# #INTcharIndex#
//    --- gatt client functionality ---
//    - Use this command to locate a characteristic in a service. It is possible 
//    - to specify index values for both service and characteristic just in case
//    - the remote server has multiple instances of service or characteristic
//
// -----------------------------------------------------------------------------
// gattc finddesc #INTconnHandle# #INTsvcuuidHandleIdx# #INTsvcIndex# \
//                #INTcharuuidHandleIdx# #INTcharIndex# #INTdescuuidHandleIdx# \
//                #INTdescIndex#
//    --- gatt client functionality ---
//    - Use this command to locate a descriptor in a characteristic of a specified
//    - service. It is possible to specify index values for service, characteristic
//    - and descriptor just in case the remote server has multiple instances of 
//    - service or characteristic or descriptor
//
// -----------------------------------------------------------------------------
// gattc open #INTbuflen# #INTflags#
//    --- gatt client functionality ---
//    - Open the gatt client
//
// -----------------------------------------------------------------------------
// gattc read #INTconnHandle# #INTattrHandle# #INToffset#
//    --- gatt client functionality ---
//    - Use this command to read the content of any particular attribute
//    - in a remote server
//
// -----------------------------------------------------------------------------
// gattc svc first #INTconnHandle# #INTstartAttrHandle# #INTsvcuuidHandleIdx#
//    --- gatt client functionality ---
//    - Find the first service starting from handle #INTstartAttrHandle# in the
//    - connection specified by #INTconnHandle# and specify a value of 0 for
//    - #INTsvcuuidHandleIdx# to look for any service, otherwise a uuid handle
//    - that will have been obtained by using the uuid command
//
// -----------------------------------------------------------------------------
// gattc svc next #INTconnHandle#
//    --- gatt client functionality ---
//    - After calling 'gattc svc first' command and getting a service use this 
//    - command to get the next service in the remote server
//
// -----------------------------------------------------------------------------
// gattc tablemap #INTconnHandle#
//    --- gatt client functionality CANNED ---
//    - used to obtain the structure of the entire gatt table in the device
//    - identified by the connection handle
//    - ERROR 00000008 will be returned if gatt client is not idle
//
// -----------------------------------------------------------------------------
// gattc write #INTconnHandle# #INTattrHandle# #HEXdata#
//    --- gatt client functionality ---
//    - Use this command to write a new value into an attribute of a remote
//    - server and the data is specified as hex digits which will be converted
//    - to binary before transmission
//
// -----------------------------------------------------------------------------
// gattc write$ #INTconnHandle# #INTattrHandle# #STRdata#
//    --- gatt client functionality ---
//    - Use this command to write a new value into an attribute of a remote
//    - server and the data is specified as a string
//
// -----------------------------------------------------------------------------
// gatts attrmetadata #INTmdindex# #INTreadrights# #INTwriterights# #INTmaxdatalen# #INTvlen#
//    --- gatt server functionality ---
//    - calls BleAttrMetaData()
//    - generate attribute metadata and store in amd[#INTmdindex#]
//
// -----------------------------------------------------------------------------
// gatts char commit #STRattr# #INThsvcidx# #INTcharhandleidx# 
//    --- gatt server functionality ---
//    - calls BleCharCommit()
//    - Commit the characteristic and store the handle for the char in hChar[#INTcharhandleidx#]
//
// -----------------------------------------------------------------------------
// gatts char descadd #STRattr# #INThuuid# #INTmddescidx# 
//    --- gatt server functionality ---
//    - calls BleCharDescAdd()
//    - add a generic descriptor to the character definition which has uuid #INThuuid#
//    - and metadata amd[#INTmddescidx#]
//
// -----------------------------------------------------------------------------
// gatts char descread #INTcharhandleidx# #INTdeschandle# #INToffset# #INTlength# #INTdescuuidHandleIdx# #STRattr$#
//    --- gatt server functionality ---
//    - calls BleCharDescRead()
//    - Use this to read the value of a descriptor that has been updated and
//    - you will know because EVCHARDESC has been thrown
//
// -----------------------------------------------------------------------------
// gatts char descprstnfrmt #INTformat# #INTexponent# #INTunit# #INTnamespace# #INTnsdesc#
//    --- gatt server functionality ---
//    - calls BleCharDescPrstnFrmt()
//    - add the presentation format descriptor to the character definition
//
// -----------------------------------------------------------------------------
// gatts char descuserdesc #STRuserdesc$# #INTmduseridx#
//    --- gatt server functionality ---
//    - calls BleCharDescUserDesc()
//    - add the user descriptor to the character definition
//
// -----------------------------------------------------------------------------
// gatts char indicate  #INTcharhandleidx# #STRattr#
//    --- gatt server functionality ---
//    - calls BleCharValueIndicate()
//    - Write to the value of hChar[#INTcharhandleidx#] into the string specified
//
// -----------------------------------------------------------------------------
// gatts char new #INTcharprops# #INThuuid# #INTmdvalidx# #INTmdcccdidx# #INTmdsccdidx#
//    --- gatt server functionality ---
//    - calls BleCharNew()
//    - start the definition of a characteristic and is not commited to the table yet
//
// -----------------------------------------------------------------------------
// gatts char notify  #INTcharhandleidx# #STRattr#
//    --- gatt server functionality ---
//    - calls BleCharValueNotify()
//    - Write to the value of hChar[#INTcharhandleidx#] into the string specified
//
// -----------------------------------------------------------------------------
// gatts char read  #INTcharhandleidx# #STRattr#
//    --- gatt server functionality ---
//    - calls BleCharValueRead()
//    - Read the value of hChar[#INTcharhandleidx#] into the string specified
//
// -----------------------------------------------------------------------------
// gatts char write  #INTcharhandleidx# #STRattr#
//    --- gatt server functionality ---
//    - calls BleCharValueWrite()
//    - Write to the value of hChar[#INTcharhandleidx#] into the string specified
//
// -----------------------------------------------------------------------------
// gatts getdevname
//    --- gatt server functionality ---
//    - calls BleGetDeviceName$() and prints the returned name
//
// -----------------------------------------------------------------------------
// gatts service commit #INTstoreIndex#
//    --- gatt server functionality ---
//    - calls BleServiceCommit()
//    - commit the service. In BL600 it is not required, BT900 it is
//
// -----------------------------------------------------------------------------
// gatts service devinfo     
//    --- gatt server functionality ---
//    - calls BleSvcRegDevInfo() and used to add  a device info service to the gatt table
//    - It takes 8 string parameters. s$[0] to s$[7]. which must be initialised
//    - using the command 'misc s$ set #INTidx# #STRescapedvalue#'  
//
// -----------------------------------------------------------------------------
// gatts service gap #STRescaped_devname# #INTwritable# #INTappearance# #INTminconnintus# #INTmaxconnintus# #INTsprtmoutus# #INTslavelatency#
//    --- gatt server functionality ---
//    - calls BleGapSvcInit() and used to update the gap service to the gatt table
//
// -----------------------------------------------------------------------------
// gatts service new #INTtype# #INThUuid# #INTstoreIndex#
//    --- gatt server functionality ---
//    - calls BleServiceNew()
//    - start a new service decleration. The handle for the service is returned
//    - in hSvc[#INTstoreIndex#] which is then subsequently used in char devclerations
//
// -----------------------------------------------------------------------------
// misc i  clearall
//    - make all elements of the entire i[] array equal to 0
//
// -----------------------------------------------------------------------------
// misc i  set #INTidx# #INTval#
//    - i[#INTidx#] = #INTval#
//    - #INTidx# will be checked for valid index 
//
// -----------------------------------------------------------------------------
// misc s$ clearall
//    - make all elements of the entire s$[] array empty
//
// -----------------------------------------------------------------------------
// misc s$ set #INTidx# #STRescapedvalue#
//    - s$[#INTidx#] = #STRescapedvalue#
//    - #INTidx# will be checked for valid index 
//
// -----------------------------------------------------------------------------
// pair defsave #INTsave#
//    - Security Manager related
//    - This will result in BleSecMngrBondReq() being called
//    - valid values for #INTsave# are
//         0     Do not performing bonding (keys not exchanged)
//         else  Perform bonding so that keys are exhanged and saved in database
//
// -----------------------------------------------------------------------------
// pair iocap #INTiocap#
//    - Security Manager related
//    - This will result in BleSecMngrIoCap() being called
//    - valid values for #INTiocap# are
//         0     None also known as ‘Just Works’ (unauthenticated pairing)
//         1     Display with Yes/No input capability (authenticated pairing)
//         2     Keyboard Only (authenticated pairing)
//         3     Display Only (authenticated pairing – if other end has input cap)
//         4     Keyboard only (authenticated pairing)
//
// -----------------------------------------------------------------------------
// pair keysize  #INTminsize# #INTmaxsize#
//    - Security Manager related
//    - This will result in BleSecMngrKeySizes() being called
//    - Specifiy the minimum and maximum key lengths
//
// -----------------------------------------------------------------------------
// pair passkey  #INTconnHandle# #INTpasscode#
//    - Security Manager related
//    - This will result in BleSecMngrPasskey() being called
//    - Valid value is 0 to 999999 for #INTpasscode# and 
//    - #INTconnHandle# sepecifies the connection handle
//
// -----------------------------------------------------------------------------
// pair start #INTconnHandle# #INTSave#
//    - Security Manager related
//    - This will result in BlePair() being called and is used to
//      initiate a pairing and if #INTSave# is 0 then here is no bonding and if 1
//      then a bonding will be performed which means the trusted device database 
//      will be updated. Any other value and whether to save or not is based
//      on the 'pair bond' command
//    - valid values for #INTsave# are
//         0     Do not performing bonding (keys not exchanged)
//         1     Perform bonding so that keys are exhanged and saved in database
//        else   Use the value as submitted via 'pair defsave'
//
// -----------------------------------------------------------------------------
// scan abort
//   - abort a scan operation (memory is not freed)
//
// -----------------------------------------------------------------------------
// scan configwr #INTcfgID# #INTvalue#
//   - set scanning configuration parameters
//     #INTcfgID# 
//       0    Scan Interval in milliseconds (range 0..10240)
//       1    Scan Window in milliseconds (range 0..10240)
//       2    Scan Type (0=Passive, 1=Active)
//       3    Advert Report Cache Size
//
// -----------------------------------------------------------------------------
// scan configrd #INTcfgID#
//   - get scanning configuration parameters
//     #INTcfgID# 
//       0    Scan Interval in milliseconds (range 0..10240)
//       1    Scan Window in milliseconds (range 0..10240)
//       2    Scan Type (0=Passive, 1=Active)
//       3    Advert Report Cache Size
//
// -----------------------------------------------------------------------------
// scan start #INTscantimeoutms# #INThandlefilter#  #INTmaxadvs#
//   - Start a scan for adverts using the timeout #INTscantimeoutms#
//   - set #INThandlefilter# to not use a whitelist
//   - Abort after #INTmaxadvs# are received, 0 for unlimited
//
// -----------------------------------------------------------------------------
// scan stop
//   - abort a scan operation (memory is freed)
//
// -----------------------------------------------------------------------------
// txpower = #INTdbm#           
//   - set tx power to #INTdbm#
//
// -----------------------------------------------------------------------------
// txpower ?                
//   - get current tx power
//
// -----------------------------------------------------------------------------

//******************************************************************************

//******************************************************************************
// Definitions
//******************************************************************************

        // Number of connections
#define NUM_OF_CONNS                         8
        // Number of services
#define NUM_OF_SVCS                          4
        // Number of attribure metadata
#define NUM_OF_METADATA                      4
        // Number of characteristics
#define NUM_OF_CHARS                         8
        // size of i[]
#define NUM_OF_I_PARAMS                     (8)
        // size of s$[] and must be at least 8 elements for BleSvcRegDevInfo()     
#define NUM_OF_S_PARAMS                     (8)
        //Number of advert reports
#define NUM_OF_ADV                          (4)

#define NUM_OF_UUID_HANDLES                 (10)

#define VSP_MAX_CHARDATA_LEN                (20)
#define VSP_RX_CHAR_HANDLE                  (17)
#define VSP_TX_CHAR_HANDLE                  (14)


//BLE EVENT MSG IDs
#define BLE_EVBLEMSGID_CONNECT                          0 // msgCtx = connection handle
#define BLE_EVBLEMSGID_DISCONNECT                       1 // msgCtx = connection handle
#define BLE_EVBLEMSGID_IMMEDIATE_ALERT_SERVICE_ALERT    2 // msgCtx = alert level
#define BLE_EVBLEMSGID_LINKLOSS_SERVICE_ALERT           3 // msgCtx = alert level
#define BLE_EVBLEMSGID_SERVICE_ERROR                    4 // msgCtx = resultcode
#define BLE_EVBLEMSGID_HTS_INDICATION_STATE             5 // msgCtx = new indication state 0=off, 1=on
#define BLE_EVBLEMSGID_HTS_INDICATION_CNF               6 // msgCtx = not used
#define BLE_EVBLEMSGID_BPS_INDICATION_STATE             7 // msgCtx = new indication state 0=off, 1=on
#define BLE_EVBLEMSGID_BPS_INDICATION_CNF               8 // msgCtx = not used
#define BLE_EVBLEMSGID_DISPLAY_PASSKEY                  9 // msgCtx = passcode to display
#define BLE_EVBLEMSGID_NEW_BOND                        10 // msgCtx = connection handle
#define BLE_EVBLEMSGID_AUTH_KEY_REQUEST                11 // msgCtx = 1 for passkey, 2 for 16 byte OOB data
#define BLE_EVBLEMSGID_HRS_NOTIFICATION_STATE          12 // msgCtx = new notification state 0=off, 1=on
//#define FUTURE_USE                                   13
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE               14 // msgCtx = connection handle
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL          15 // msgCtx = connection handle
#define BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER           16 // msgCtx = connection handle
#define BLE_EVBLEMSGID_UPDATED_BOND                    17 // msgCtx = connection handle
#define BLE_EVBLEMSGID_ENCRYPTED                       18 // msgCtx = connection handle
#define BLE_EVBLEMSGID_POWER_FAILURE_WARNING           19 // msgCtx = current supply voltage
#define BLE_EVBLEMSGID_UNENCRYPTED                     20 // msgCtx = connection handle
#define BLE_EVBLEMSGID_DEVICENAME_WRITE                21 // msgCtx = connection handle 

//******************************************************************************
// Register Error Handler as early as possible
//******************************************************************************
sub HandlerOnErr()
  print "\n OnErr - ";GetLastError();"\n"
endsub
onerror next HandlerOnErr

//******************************************************************************
// Debugging resource as early as possible
//******************************************************************************

//==============================================================================
//==============================================================================
sub AssertResCode(byval rc as integer,byval tag as integer)
  if rc!=0 then
    print "\nFailed with ";integer.h' rc;" at tag ";tag
  endif
endsub

//******************************************************************************
// Library Import
//******************************************************************************

//******************************************************************************
// Debugging resource after libs
//******************************************************************************

//******************************************************************************
// Global Variable Declarations
//******************************************************************************

dim rc
dim stRsp$ as string        //Uart rx data is stored here

dim ok$,er$,pr$

dim i[NUM_OF_I_PARAMS]      // index 0 used for return values
dim s$[NUM_OF_S_PARAMS]    // must be at least 8 elements for BleSvcRegDevInfo()

dim urtcmd$                 //cmd line from uart
dim tkn$,tlen               //used by command parser
dim hSvc[NUM_OF_SVCS]       //gatts : handle for new service being created is in index 0
dim amd[NUM_OF_METADATA]    //gatts : attribute meta data
dim hchar[NUM_OF_CHARS]     //gatts : handles for characteristics
dim hc[NUM_OF_CONNS+1]      //contains connection handles
dim hu[NUM_OF_UUID_HANDLES+1] //contains uuid handles
dim conns                   //number of connections
dim gcState                 // gatt client state, 0=IDLE, 1=TableMapping
dim urts                    //will be <0 if uart parser suspended
dim hcVsp                   //handle of connection to use for VSP service
dim vdta$                   //data to send over virtual serial port
dim vsplen                  //0 implies can send data. >0 waiting for notify event
dim vspRxH                  //handle of the RX char in the peripheral for VSP
dim vspTxH                  //handle of the TX char in the peripheral for VSP
dim advcnt                  //count of adverts received after scan start
dim advmax                  //max adverts to receive, 0 means unlimited
dim adv$[NUM_OF_ADV]        //advert reports

//******************************************************************************
// Initialisse Global Variable
//******************************************************************************

ok$    = "\nOK"
er$    = "\nERROR "
pr$    = "\r\n>"

gcState = 0 // gatt client is idle
urts=0 //not suspended
conns = 0  //number of connections
hcVsp = -1
vsplen = 0
vspRxH = VSP_RX_CHAR_HANDLE
vspTxH = VSP_TX_CHAR_HANDLE

hu[0] = 0 // this is the invalid uuid handle

//******************************************************************************
// Function and Subroutine definitions
//******************************************************************************


//==============================================================================
//==============================================================================
function ClearS() 
  dim j
  for j = 0 to (NUM_OF_S_PARAMS-1)
    s$[j]=""
  next
endfunc 0

//==============================================================================
//==============================================================================
function ClearI()
  dim j
  for j = 0 to (NUM_OF_I_PARAMS-1)
    i[j]=0
  next
endfunc 0

//==============================================================================
//release all connection handles
//==============================================================================
sub InitConnHandles()
  dim z
  for z=0 to (NUM_OF_CONNS)
    hc[z]=-1
  next
endsub

//==============================================================================
//==============================================================================
function AcqConnHandle(hConn)
  dim z
  for z=1 to (NUM_OF_CONNS)
    if hc[z] == -1 then
      hc[z]=hConn
      exitfunc z
    endif
  next
endfunc 0

//==============================================================================
//==============================================================================
function RelConnHandle(hConn)
  dim z
  for z=1 to (NUM_OF_CONNS)
    if hc[z] == hConn then 
      hc[z]=-1
      exitfunc z
    endif
  next
endfunc 0

//==============================================================================
//==============================================================================
sub UartRsp(rsp as integer)
  if rsp == 0 then
    print ok$;pr$
  elseif rsp > 0 then 
    print er$;integer.h' rsp;pr$
  endif
  urts = rsp
endsub

//==============================================================================
//==============================================================================
function InitiateTableMap(hConn)
  rc = BleDiscServiceFirst(hConn,0,0)
  if rc==0 then
    gcState=1
    exitfunc -1
  endif
endfunc rc

//==============================================================================
//==============================================================================
sub TerminateTableMap(rc)
  gcState=0
  if rc==0x6052 then
    //BLE_GATTC_NO_MORE_DATA
    rc=0
  endif
  UartRsp(rc)
endsub

//==============================================================================
//==============================================================================
sub ShowConnParms(nCtx as integer)
  dim intrvl,sprvto,slat
  rc= BleGetCurConnParms(nCtx,intrvl,sprvto,slat)
  AssertResCode(rc,1240)
  if rc==0 then
    print "\nConn Interval ";intrvl
    print "\nConn Supervision Timeout ";sprvto
    print "\nConn Slave Latency ";slat
  endif
endsub

//==============================================================================
// for = Y returns -1 and val==Y
// for ? returns 0
// otherwise return 1
//==============================================================================
function ParseSetQuery(byref val as integer)
  rc = 1
  tlen = ExtractStrToken(urtcmd$,tkn$)
  if tlen > 0 then
    if strcmp(tkn$,"?")==0 then
      rc=0
    elseif strcmp(tkn$,"=")==0 then
      tlen = ExtractIntToken(urtcmd$,val)
      if tlen > 0 then
        rc=-1
      endif
    endif
  endif
endfunc rc

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
function ExtractIntTokens(u$,stIdx,num)
  while num>0
    tlen = ExtractIntToken(u$,i[stIdx])
    if tlen == 0 then
      exitfunc 4
    endif
    num=num-1
    stIdx = stIdx+1
  endwhile
endfunc 0

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
function ExtractStrTokens(u$,stIdx,num)
  while num>0
    tlen = ExtractStrToken(u$,s$[stIdx])
    if tlen == 0 then
      exitfunc 3
    endif
    num=num-1
    stIdx = stIdx+1
  endwhile
endfunc 0

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
function ExtractAddrTokens(u$,stIdx,num)
  while num>0
    tlen = ExtractStrToken(u$,tkn$)
    if tlen == 0 then
      exitfunc 3
    endif
    s$[stIdx]=StrDehexize$(tkn$)
    if strlen(s$[stIdx]) != 7 then
      exitfunc 5
    endif
    num=num-1
    stIdx = stIdx+1
  endwhile
endfunc 0

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
function _IsTrusted( age )
  dim keyInfo,tmp
  //the next token has to be a mac address
  rc = ExtractAddrTokens(urtcmd$,1,1)
  if tlen == 0 then
    exitfunc 5
  endif
  //extract 1 (#INTasCentral#) and store starting at i[1]
  rc = ExtractIntTokens(urtcmd$,1,1)
  if rc != 0 then
    exitfunc rc
  endif
  i[0] = BleBondingIsTrusted(s$[1],i[1],keyInfo,i[2],i[3])
  if i[0] <= 0 then
    print "\nNOT trusted"
  else
    print "\nTrusted : Addr="; strhexize$(s$[1])
    print "  Len=";i[0];" "
    tmp=keyInfo & 0x01
    if tmp==0 then
      print " -"
    else
      print " +"
    endif
    print "MITM"        
  endif    
endfunc 0

//==============================================================================
//==============================================================================
sub ReadAdvReports(avmx, byref acnt)  //avmx to 0 to set no limit
  dim ad$,dta$,ndisc,rsi,prn
  prn=1
  rc = BleScanGetAdvReport(ad$,dta$,ndisc,rsi)
  AssertResCode(rc,742)
  while rc==0    
    if avmx != 0 then
      acnt = acnt + 1
      if acnt > avmx then
        prn=0
        break
      endif
    endif
    if prn != 0 then
      print "\nADV:";strhexize$(ad$);" AD:";strhexize$(dta$);" XX:";ndisc;" RS:";rsi
    endif
    rc = BleScanGetAdvReport(ad$,dta$,ndisc,rsi)
  endwhile
  if prn == 0 then
    //need to abort scan as we have received enough
    rc=BleScanStop()
  endif
endsub

//==============================================================================
// This handler is called when there is an advert report waiting to be read
//==============================================================================
function HandlerAdvRptNoRd() as integer
  advcnt = advcnt+1
endfunc 1


//-------------------------------------------------------------------------
//#CMD#// txpower = #INTdbm#       - set tx power to #INTdbm#
//#CMD#// txpower ?                - get tx power
//-------------------------------------------------------------------------
function _TxPower()
  rc = ParseSetQuery(i[1])
  select rc
  case 0
    print "\nCurrent TxPower = ";SysInfo(2008)
    rc=0
  case -1
    print "\nSet TxPower = ";i[1]
    rc=BleTxPowerSet(i[1])
  case else
  endselect
endfunc rc

//-------------------------------------------------------------------------
//#CMD#// advert report initadv   #INTadvidx# #INTadflags# #INTadappearance# #INTmaxdevname#
//#CMD#// advert report initscn   #INTadvidx#
//#CMD#// advert report ADuuid16  #INTadvidx# #INTuuid0# #INTuuid1# #INTuuid2# #INTuuid3# #INTuuid4# #INTuuid5#
//#CMD#// advert report ADuuid128 #INTadvidx# #INTuuidhandle#
//#CMD#// advert report ADany     #INTadvidx# #INTtag# #HEXdata$#
//#CMD#// advert report commit    #INTadvidx0# #INTadvidx1#
//#CMD#// advert undirected       #INTintervalms# #INTtimeoutms# #INTfilterpolicy#
//#CMD#// advert scan             #INTintervalms# #INTtimeoutms# #INTfilterpolicy#
//#CMD#// advert nonconn          #INTintervalms# #INTtimeoutms# #INTfilterpolicy#
//#CMD#// advert directed         #INTintervalms# #INTtimeoutms# #INTfilterpolicy# #HEXaddr14Bytes#
//#CMD#// advert stop
//-------------------------------------------------------------------------
function _Advert()
  dim prAdr$ 
  tlen = ExtractStrToken(urtcmd$,tkn$)
  if tlen == 0 then
    exitfunc 5
  endif
  //=================================================
  if strcmp(tkn$,"report")==0 then
    tlen = ExtractStrToken(urtcmd$,tkn$)
    if tlen == 0 then
      exitfunc 5
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"initadv")==0 then
      //extract 4 (#INTadvidx# #INTadflags# #INTadappearance# #INTmaxdevname#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,4)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleAdvRptInit(adv$[i[1]],i[2],i[3],i[4])
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"initscn")==0 then
      //extract 1 (#INTadvidx#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleScanRptInit(adv$[i[1]])
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"ADuuid16")==0 then
      //extract 7 (#INTadvidx# #INTuuid0# #INTuuid1# #INTuuid2# #INTuuid3# #INTuuid4# #INTuuid5#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,7)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleAdvRptAddUuid16(adv$[i[1]],i[2],i[3],i[4],i[5],i[6],i[7])
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"ADuuid128")==0 then
      //extract 2 (#INTadvidx# #INTuuidhandle#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,2)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleAdvRptAddUuid128(adv$[i[1]],i[2])
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"ADany")==0 then
      //extract 2 (#INTadvidx# #INTtag#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,2)
      if rc != 0 then
        exitfunc rc
      endif
      //extract 1 (#HEXdata$#) and store starting at s[1]
      rc = ExtractStrTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      s$[1]=StrDehexize$(s$[1]) //convert from hex to binary
      exitfunc BleAdvRptAppendAD(adv$[i[1]],i[2],s$[1])
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"commit")==0 then
      //extract 2 (#INTadvidx0# #INTadvidx1#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,2)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleAdvRptsCommit(adv$[i[1]],adv$[i[2]])
    endif
    prAdr$=""
  endif  
  //=================================================
  if strcmp(tkn$,"undirected")==0 then
    //extract 3 (#INTintervalms# #INTtimeoutms# #INTfilterpolicy#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,3)
    if rc != 0 then
      exitfunc rc
    endif
    exitfunc BleAdvertStart(0,prAdr$,i[1],i[2],i[3])
  endif
  //=================================================
  if strcmp(tkn$,"scan")==0 then
    //extract 3 (#INTintervalms# #INTtimeoutms# #INTfilterpolicy#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,3)
    if rc != 0 then
      exitfunc rc
    endif
    exitfunc BleAdvertStart(2,prAdr$,i[1],i[2],i[3])
  endif
  //=================================================
  if strcmp(tkn$,"nonconn")==0 then
    //extract 3 (#INTintervalms# #INTtimeoutms# #INTfilterpolicy#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,3)
    if rc != 0 then
      exitfunc rc
    endif
    exitfunc BleAdvertStart(3,prAdr$,i[1],i[2],i[3])
  endif
  //=================================================
  if strcmp(tkn$,"directed")==0 then
    //extract 3 (#INTintervalms# #INTtimeoutms# #INTfilterpolicy#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,3)
    if rc != 0 then
      exitfunc rc
    endif
    //extract 1 (#HEXaddr14Bytes#) and store starting at s$[1] which has to be a mac address
    rc = ExtractStrTokens(urtcmd$,1,1)
    if rc != 0 then
      exitfunc rc
    endif
    prAdr$=StrDehexize$(s$[1])
    if strlen(prAdr$) != 7 then
      exitfunc 5
    endif
    exitfunc BleAdvertStart(1,prAdr$,i[1],i[2],i[3])
  endif
  //=================================================
  if strcmp(tkn$,"stop")==0 then
    exitfunc BleAdvertStop()
  endif
endfunc 5

//-------------------------------------------------------------------------
//#CMD#//  scan abort
//#CMD#//  scan stop
//#CMD#//  scan noautoread
//#CMD#//  scan readadverts #INTmaxread#
//#CMD#//  scan configwr #INTcfgID# #INTvalue#
//#CMD#//  scan configrd #INTcfgID#
//#CMD#//  scan start #INTscantimeoutms# #INThandlefilter# #INTmaxadvs#
//-------------------------------------------------------------------------
function _Scan()  
  tlen = ExtractStrToken(urtcmd$,tkn$)
  if tlen == 0 then
    exitfunc 5
  endif
  if strcmp(tkn$,"stop")==0 then
    //cancel the connection attempt (release memory)
    exitfunc BleScanStop()
  endif
  if strcmp(tkn$,"abort")==0 then
    //cancel the connection attempt (do not release memory)
    exitfunc BleScanAbort()
  endif
  if strcmp(tkn$,"noautoread")==0 then
    //change the EVBLE_ADV_REPORT handler, so that adverts are not autoread
    OnEvent  EVBLE_ADV_REPORT  call HandlerAdvRptNoRd
    exitfunc 0
  endif
  if strcmp(tkn$,"readadverts")==0 then
    //Read the advert reports
    //extract 1 : (#INTmaxread#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,1)
    if rc != 0 then
      exitfunc rc
    endif
    i[2]=0
    ReadAdvReports(i[1],i[2])
    exitfunc 0
  endif
  if strcmp(tkn$,"configwr")==0 then
    //extract 2 : (#cfgID #value) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,2)
    if rc != 0 then
      exitfunc rc
    endif
    exitfunc BleScanConfig(i[1],i[2])  
  endif
  if strcmp(tkn$,"configrd")==0 then
    //extract 1 : (#cfgID ) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,1)
    if rc != 0 then
      exitfunc rc
    endif
    i[0]=SysInfo(2150+i[1])
    print "\nScan Config ";i[1];" is ";i[0]
    rc=0
    exitfunc rc
  endif
  if strcmp(tkn$,"start")==0 then
    //extract 3 : (scantimeoutms handleFilter maxadvs) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,3)
    print i[1], i[2]
    if rc != 0 then
      exitfunc rc
    endif
    advcnt=0
    advmax=i[3]
    rc = BleScanStart(i[1],i[2])
    exitfunc rc
  endif
endfunc 5

//-------------------------------------------------------------------------
//#CMD#//  connect cancel
//#CMD#//  connect configwr #INTcfgID# #INTvalue#
//#CMD#//  connect configrd #INTcfgID#
//#CMD#//  connect connparms #INTconnHandle# #INTminConnIntMs# #INTmaxConnIntMs# #INTsprvsnToutMs# #INTslavelatency#
//#CMD#//  connect encrypt #INTconnHandle# #INTminKeySize# #INTmitmRequired#
//#CMD#//  connect #HEXaddr14Bytes# #INTconntimeoutms# #INTminConnIntUs# #INTmaxConnIntUs# #INTsprvsnToutUs#
//-------------------------------------------------------------------------
function _Connect()  
  tlen = ExtractStrToken(urtcmd$,tkn$)
  if tlen == 0 then
    exitfunc 5
  endif
  //=================================================
  if strcmp(tkn$,"cancel")==0 then
    //cancel the connection attempt
    exitfunc BleConnectCancel()
  endif
  //=================================================
  if strcmp(tkn$,"configwr")==0 then
    //extract 2 : (#cfgID #value) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,2)
    if rc != 0 then
      exitfunc rc
    endif
    exitfunc BleConnectConfig(i[1],i[2])  
  endif
  //=================================================
  if strcmp(tkn$,"configrd")==0 then
    //extract 1 : (#cfgID ) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,1)
    if rc != 0 then
      exitfunc rc
    endif
    i[0]=SysInfo(2100+i[1])
    print "\nConn Config ";i[1];" is ";i[0]
    rc=0
    exitfunc rc
  endif
  //=================================================
  if strcmp(tkn$,"encrypt")==0 then
    //extract 3 : (#INTconnHandle# #INTminKeySize# #INTmitmRequired#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,3)
    if rc != 0 then
      exitfunc rc
    endif
    exitfunc BleEncryptConnection(hc[i[1]],i[2],i[3])  
  endif
  //=================================================
  if strcmp(tkn$,"connparms")==0 then
    //extract 5 : (#INTconnHandle# #INTminConnIntMs# #INTmaxConnIntMs# #INTsprvsnToutMs# #INTslavelatency#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,5)
    if rc != 0 then
      exitfunc rc
    endif
    exitfunc BleSetCurConnParms(hc[i[1]],i[2],i[3],i[4],i[5])  
  endif
  
  //=================================================
  //the current token has to be a mac address
  s$[1]=StrDehexize$(tkn$)
  if strlen(s$[1]) != 7 then
    exitfunc 5
  endif
  //extract 4 : (conntimeoutms minConnIntMs maxConnIntMs sprvsnToutMs) and store starting at i[1]
  rc = ExtractIntTokens(urtcmd$,1,4)
  if rc != 0 then
    exitfunc rc
  endif
endfunc BleConnect(s$[1],i[1],i[2],i[3],i[4])

//-------------------------------------------------------------------------
//#CMD#//  disconnect #INTconnHandle#
//-------------------------------------------------------------------------
function _Disconnect()
  dim hz
  // extract the optional handle
  tlen = ExtractIntToken(urtcmd$,i[1])
  // handle was supplied
  hz=hc[i[1]]
  print "\nDisconnecting ";i[1];" handle = ";integer.h' hz
endfunc BleDisconnect(hz)

//-------------------------------------------------------------------------
//#CMD#//  uuid new     #INTuuidHandleIndex# #HEXhexChrs# 
//#CMD#//  uuid sibling #INTuuidHandleIndex# #INTuuidHandleIndexBase# #INT16bitUuid# 
//-------------------------------------------------------------------------
function _uuid()
  dim v16
  tlen = ExtractStrToken(urtcmd$,tkn$)
  if tlen == 0 then
    exitfunc 5
  endif
  if strcmp(tkn$,"new")==0 then
    //extract 1 (#INTuuidHandleIndex#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,1)
    if rc != 0 then
      exitfunc rc
    endif
    //extract 1 (#HEXhexChrs#) and store starting at s$[1]
    tlen = ExtractStrToken(urtcmd$,tkn$)
    if tlen == 0 then
      exitfunc 5
    endif
    if tlen == 32 then
      s$[1]=StrDehexize$(tkn$)
      hu[i[1]] = BleHandleUuid128(s$[1])
    elseif tlen == 4 then
      s$[1]=StrDehexize$(tkn$)
      v16 = (StrGetChr(s$[1],0)*256) + StrGetChr(s$[1],1)
      hu[i[1]] = BleHandleUuid16(v16)
    else
      exitfunc 5
    endif
    exitfunc 0
  endif
  if strcmp(tkn$,"sibling")==0 then
    //extract 3 (#INTuuidHandleIndex# #INTuuidHandleIndexBase# #INT16bitUuid#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,3)
    if rc != 0 then
      exitfunc rc
    endif
    hu[i[1]] = BleHandleUuidSibling(hu[i[2]],i[3])
    exitfunc 0
  endif
endfunc 5

//-------------------------------------------------------------------------
//
//#CMD#//  uuid new     #INTuuidHandleIndex# #HEXhexChrs# 
//#CMD#//  uuid sibling #INTuuidHandleIndex# #INTuuidHandleIndexBase# #INT16bitUuid# 
//
//#CMD#//  gattc open #INTbuflen# #INTflags#
//#CMD#//  gattc close
//#CMD#//  gattc svc first #INTconnHandleIdx# #INTstartAttrHandle# #INTsvcUuidHandleIdx#
//#CMD#//  gattc svc next #INTconnHandleIdx#
//#CMD#//  gattc char first #INTconnHandleIdx# #INTUuidHandleIdx# #INTsvcStartAttrHandle# #INTsvcEndAttrHandle#
//#CMD#//  gattc char next #INTconnHandleIdx#
//#CMD#//  gattc desc first #INTconnHandleIdx# #INTUuidHandleIdx# #INTcharStartAttrHandle#
//#CMD#//  gattc desc next #INTconnHandleIdx#
//#CMD#//  gattc findchar #INTconnHandleIdx# #INTsvcUuidHandleIdx# #INTsvcInstance# #INTcharUuidHandleIdx# #INTcharInstance#
//#CMD#//  gattc finddesc #INTconnHandleIdx# #INTsvcUuidHandleIdx# #INTsvcInstance# #INTcharUuidHandleIdx# #INTcharInstance# #INTdescUuidHandleIdx# #INTdescInstance#
//#CMD#//  gattc tablemap #INTconnHandleIdx#
//#CMD#//  gattc read #INTconnHandleIdx# #INTattrHandle# #INToffset#
//#CMD#//  gattc write #INTconnHandleIdx# #INTattrHandle# #HEXdata#
//#CMD#//  gattc write$ #INTconnHandleIdx# #INTattrHandle# #STRdata#
//-------------------------------------------------------------------------
function _Gattc()  
  dim cmdid
  tlen = ExtractStrToken(urtcmd$,tkn$)
  if tlen == 0 then
    exitfunc 5
  endif
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if strcmp(tkn$,"open")==0 then
    //extract 2 (#INTbuflen# #INTflags#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,2)
    if rc != 0 then
      exitfunc rc
    endif
    exitfunc BleGattcOpen(i[1],i[2])
  endif
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if strcmp(tkn$,"close")==0 then
    //no parms to extract
    BleGattcClose()
    exitfunc 0
  endif
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if strcmp(tkn$,"svc")==0 then
    if gcState!=0 then
      exitfunc 8
    endif
    tlen = ExtractStrToken(urtcmd$,tkn$)
    if tlen == 0 then
      exitfunc 5
    endif  
    if strcmp(tkn$,"first")==0 then
      //extract 3 (#INTconnHandle# #INTstartAttrHandle# #INTsvcUuidHandleIdx#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,3)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleDiscServiceFirst(hc[i[1]],i[2],hu[i[3]])
    endif
    if strcmp(tkn$,"next")==0 then
      //extract 1 (#INTconnHandle#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleDiscServiceNext(hc[i[1]])
    endif
  endif
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if strcmp(tkn$,"char")==0 then
    if gcState!=0 then
      exitfunc 8
    endif
    tlen = ExtractStrToken(urtcmd$,tkn$)
    if tlen == 0 then
      exitfunc 5
    endif  
    if strcmp(tkn$,"first")==0 then
      //extract 4 (#INTconnHandle# #INTUuidHandleIdx# #INTsvcStartAttrHandle# #INTsvcEndAttrHandle#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,4)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleDiscCharFirst(hc[i[1]],hu[i[2]],i[3],i[4])
    endif
    if strcmp(tkn$,"next")==0 then
      //extract 1 (#INTconnHandle#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleDiscCharNext(hc[i[1]])
    endif
  endif
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if strcmp(tkn$,"desc")==0 then
    if gcState!=0 then
      exitfunc 8
    endif
    tlen = ExtractStrToken(urtcmd$,tkn$)
    if tlen == 0 then
      exitfunc 5
    endif  
    if strcmp(tkn$,"first")==0 then
      //extract 3 (#INTconnHandle# #INTUuidHandleIdx# #INTcharStartAttrHandle#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,3)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleDiscDescFirst(hc[i[1]],hu[i[2]],i[3])
    endif
    if strcmp(tkn$,"next")==0 then
      //extract 1 (#INTconnHandle#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleDiscDescNext(hc[i[1]])
    endif
  endif
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if strcmp(tkn$,"findchar")==0 then
    //extract 5 (#INTconnHandleIdx# #INTsvcUuidHandleIdx# #INTsvcInstance# #INTcharUuidHandleIdx# #INTcharInstance#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,5)
    if rc != 0 then
      exitfunc rc
    endif
    exitfunc BleGattcFindChar(hc[i[1]],hu[i[2]],i[3],hu[i[4]],i[5])
  endif
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if strcmp(tkn$,"finddesc")==0 then
    //extract 7 (#INTconnHandleIdx# #INTsvcUuidHandleIdx# #INTsvcInstance# #INTcharUuidHandleIdx# #INTcharInstance# #INTdescUuidHandleIdx# #INTdescInstance#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,7)
    if rc != 0 then
      exitfunc rc
    endif
    exitfunc BleGattcFindDesc(hc[i[1]],hu[i[2]],i[3],hu[i[4]],i[5],hu[i[6]],i[7])
  endif
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if strcmp(tkn$,"tablemap")==0 then
    if gcState!=0 then
      exitfunc 8
    endif
    //extract 1 (#INTconnHandle#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,1)
    if rc != 0 then
      exitfunc rc
    endif
    exitfunc InitiateTableMap(hc[i[1]])
  endif
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if strcmp(tkn$,"read")==0 then
    //extract 3 (#INTconnHandle# #INTattrHandle# #INToffset#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,3)
    if rc != 0 then
      exitfunc rc
    endif
    exitfunc BleGattcRead(hc[i[1]],i[2],i[3])
  endif
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  cmdid=0
  if strcmp(tkn$,"write")==0 then
    cmdid=1
  endif
  if strcmp(tkn$,"write$")==0 then
    cmdid=2
  endif
  if cmdId != 0 then
    //extract 3 (#INTconnHandle# #INTattrHandle# #HEXdata#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,2)
    if rc != 0 then
      exitfunc rc
    endif
    if cmdid==1 then
      //extract 1 (#HEXdata#) and store starting at s$[1]
      tlen = ExtractStrToken(urtcmd$,s$[1])
      if tlen == 0 then
        exitfunc 5
      endif
      s$[1]=StrDehexize$(s$[1])
      tlen = strlen(s$[1])
    else
      //extract 1 (#STRdata#) and store starting at s$[1]
      tlen = ExtractStrToken(urtcmd$,s$[1])
    endif
    if tlen<1  then
      exitfunc 5
    endif    
    exitfunc BleGattcWrite(hc[i[1]],i[2],s$[1])
  endif
  cmdid=0
  if strcmp(tkn$,"write")==0 then
    cmdid=0x01
  endif
  if strcmp(tkn$,"write$")==0 then
    cmdid=0x02
  endif
  if strcmp(tkn$,"writecmd")==0 then
    cmdid=0x11
  endif
  if strcmp(tkn$,"writecmd$")==0 then
    cmdid=0x12
  endif
  if cmdId != 0 then
    //extract 3 (#INTconnHandle# #INTattrHandle# #HEXdata#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,2)
    if rc != 0 then
      exitfunc rc
    endif
    if (cmdid & 0xF)==1 then
      //extract 1 (#HEXdata#) and store starting at s$[1]
      tlen = ExtractStrToken(urtcmd$,s$[1])
      if tlen == 0 then
        exitfunc 5
      endif
      s$[1]=StrDehexize$(s$[1])
      tlen = strlen(s$[1])
    else
      //extract 1 (#STRdata#) and store starting at s$[1]
      tlen = ExtractStrToken(urtcmd$,s$[1])
    endif
    if tlen<1  then
      exitfunc 5
    endif    
    if (cmdid & 0xF0)==0 then
      exitfunc BleGattcWrite(hc[i[1]],i[2],s$[1])
    else
      exitfunc BleGattcWriteCmd(hc[i[1]],i[2],s$[1])
    endif
  endif
endfunc 5

//-------------------------------------------------------------------------
//#CMD#//  gatts getdevname
//#CMD#//  gatts service new        #INTtype# #INThUuidIdx# #INTstoreIndex#
//#CMD#//  gatts service commit     #INTstoreIndex#
//#CMD#//  gatts service gap        #STRescaped_devname# #INTwritable# #INTappearance# #INTminconnintus# #INTmaxconnintus# #INTsprtmoutus# #INTslavelatency#
//#CMD#//  gatts service devinfo     
//#CMD#//  gatts attrmetadata       #INTmdindex# #INTreadrights# #INTwriterights# #INTmaxdatalen# #INTvlen#
//#CMD#//  gatts char new           #INTcharprops# #INThuuidIdx# #INTmdvalidx# #INTmdcccdidx# #INTmdsccdidx#
//#CMD#//  gatts char descuserdesc  #STRuserdesc$# #INTmduseridx#
//#CMD#//  gatts char descprstnfrmt #INTformat# #INTexponent# #INTunit# #INTnamespace# #INTnsdesc#
//#CMD#//  gatts char descadd       #STRattr# #INThuuidIdx# #INTmddescidx# 
//#CMD#//  gatts char commit        #STRattr# #INThsvcidx# #INTcharhandleidx# 
//#CMD#//  gatts char read          #INTcharhandleidx# #STRattr#
//#CMD#//  gatts char write         #INTcharhandleidx# #STRattr#
//#CMD#//  gatts char notify        #INTcharhandleidx# #STRattr#
//#CMD#//  gatts char indicate      #INTcharhandleidx# #STRattr#
//#CMD#//  gatts char descread      #INTcharhandleidx# #INTdeschandle# #INToffset# #INTlength# #INTdescUuidHandleIdx# #STRattr#
//-------------------------------------------------------------------------
function _Gatts()  
  tlen = ExtractStrToken(urtcmd$,tkn$)
  if tlen == 0 then
    exitfunc 5
  endif
  //=================================================
  if strcmp(tkn$,"getdevname")==0 then
    print "\n";BleGetDeviceName$();"\r"
    exitfunc 0
  endif
  //=================================================
  if strcmp(tkn$,"service")==0 then
    tlen = ExtractStrToken(urtcmd$,tkn$)
    if tlen == 0 then
      exitfunc 5
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"new")==0 then
      //extract 3 (#INTtype# #INThUuidIdx# #INTstoreIndex#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,3)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleServiceNew(i[1],hu[i[2]],hSvc[i[3]])
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"commit")==0 then
      //extract 1 (#INTstoreIndex#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleServiceCommit(hSvc[i[3]])
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"gap")==0 then
      //extract 1 (#STRescaped_devname#) and store starting at s$[1]
      rc = ExtractStrTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      StrDeEscape(s$[1])
      //extract 6 (#INTwritable# #INTappearance# #INTminconnintus# #INTmaxconnintus# #INTsprtmoutus# #INTslavelatency#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,6)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleGapSvcInit(s$[1],i[1],i[2],i[3],i[4],i[5],i[6])
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"devinfo")==0 then
      exitfunc BleSvcRegDevInfo(s$[0],s$[1],s$[2],s$[3],s$[4],s$[5],s$[6],s$[7])
    endif
  endif
  //=================================================
  if strcmp(tkn$,"attrmetadata")==0 then
    //extract 5 (#INTmdindex# #INTreadrights# #INTwriterights# #INTmaxdatalen# #INTvlen#) and store starting at i[0]
    rc = ExtractIntTokens(urtcmd$,0,5)
    if rc != 0 then
      exitfunc rc
    endif
    amd[i[0]] = BleAttrMetaData(i[1],i[2],i[3],i[4],rc)
    exitfunc rc
  endif
  //=================================================
  if strcmp(tkn$,"char")==0 then
    tlen = ExtractStrToken(urtcmd$,tkn$)
    if tlen == 0 then
      exitfunc 5
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"new")==0 then
      //extract 5 (#INTcharprops# #INThuuidIdx# #INTmdvalidx# #INTmdcccdidx# #INTmdsccdidx#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,5)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleCharNew(i[1],hu[i[2]],amd[i[3]],amd[i[4]],amd[i[5]])
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"descuserdesc")==0 then
      //extract 1 (#STRuserdesc$#) and store starting at s$[1]
      rc = ExtractStrTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      //extract 1 (#INTmduseridx#) and store starting at i[1]
      rc = ExtractStrTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleCharDescUserDesc(s$[1],amd[i[1]])
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"descprstnfrmt")==0 then
      //extract 5 (#INTformat# #INTexponent# #INTunit# #INTnamespace# #INTnsdesc#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,5)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleCharDescPrstnFrmt(i[1],i[2],i[3],i[4],i[5])
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"descadd")==0 then
      //extract 1 (#STRattr$#) and store starting at s$[1]
      rc = ExtractStrTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      //extract 2 (#INThuuidIdx# #INTmddescidx#) and store starting at i[1]
      rc = ExtractStrTokens(urtcmd$,1,2)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleCharDescAdd(hu[i[1]],s$[1],amd[i[2]])
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"commit")==0 then
      //extract 1 (#STRattr$#) and store starting at s$[1]
      rc = ExtractStrTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      //extract 2 (#INThsvcidx# #INTcharhandleidx#) and store starting at i[1]
      rc = ExtractStrTokens(urtcmd$,1,2)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleCharCommit(hSvc[i[1]],s$[1],hchar[i[2]])
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"read")==0 then
      //extract 1 (#INTcharhandleidx#) and store starting at i[1]
      rc = ExtractStrTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      //extract 1 (#STRattr$#) and store starting at s$[1]
      rc = ExtractStrTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleCharValueRead(hChar[i[1]],s$[1])
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"write")==0 then
      //extract 1 (#INTcharhandleidx#) and store starting at i[1]
      rc = ExtractStrTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      //extract 1 (#STRattr$#) and store starting at s$[1]
      rc = ExtractStrTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleCharValueWrite(hChar[i[1]],s$[1])
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"Notify")==0 then
      //extract 1 (#INTcharhandleidx#) and store starting at i[1]
      rc = ExtractStrTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      //extract 1 (#STRattr$#) and store starting at s$[1]
      rc = ExtractStrTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleCharValueNotify(hChar[i[1]],s$[1])
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"indicate")==0 then
      //extract 1 (#INTcharhandleidx#) and store starting at i[1]
      rc = ExtractStrTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      //extract 1 (#STRattr$#) and store starting at s$[1]
      rc = ExtractStrTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleCharValueIndicate(hChar[i[1]],s$[1])
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"descread")==0 then
      //extract 5 (#INTcharhandleidx# #INTdeschandle# #INToffset# #INTlength# #INTdescuuidhandleIdx#) and store starting at i[1]
      rc = ExtractStrTokens(urtcmd$,1,5)
      if rc != 0 then
        exitfunc rc
      endif
      //extract 1 (#STRattr$#) and store starting at s$[1]
      rc = ExtractStrTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      exitfunc BleCharDescRead(hChar[i[1]],i[2],i[3],i[4],hu[i[5]],s$[1])
    endif
  endif
endfunc 5

//-------------------------------------------------------------------------
//#CMD#//  pair keysize  #INTminsize# #INTmaxsize#
//#CMD#//  pair iocap    #INTiocap#
//#CMD#//  pair defconf  #INTval#
//#CMD#//  pair defSave  #INTsave#
//#CMD#//  pair passkey  #INTconnHandle# #INTpasscode#
//#CMD#//  pair start    #INTconnHandle# #INTsave#
//#CMD#//  pair accept   #INTconnHandle# #INTYesNo#
//-------------------------------------------------------------------------
function _Pair()  
  tlen = ExtractStrToken(urtcmd$,tkn$)
  if tlen == 0 then
    exitfunc 5
  endif
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if strcmp(tkn$,"accept")==0 then
    //extract 2 (#INTconnHandle# #INTYesNo#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,2)
    if rc != 0 then
      exitfunc rc
    endif
    exitfunc BleAcceptPairing(hc[i[1]],i[2])
  endif  
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if strcmp(tkn$,"defconf")==0 then
    //extract 1 (#INTsave# ) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,1)
    if rc != 0 then
      exitfunc rc
    endif
    exitfunc BleSecMngrJustWorksConf(i[1])
  endif  
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if strcmp(tkn$,"keysize")==0 then
    //extract 2 (#INTminsize# #INTmaxsize#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,2)
    if rc != 0 then
      exitfunc rc
    endif
    exitfunc BleSecMngrKeySizes(i[1],i[2])
  endif  
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if strcmp(tkn$,"iocap")==0 then
    //extract 1 (#INTiocap#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,1)
    if rc != 0 then
      exitfunc rc
    endif
    exitfunc BleSecMngrIoCap(i[1])
  endif  
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if strcmp(tkn$,"passkey")==0 then
    //extract 2 (#INTconnHandle# #INTpasscode#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,2)
    if rc != 0 then
      exitfunc rc
    endif
    exitfunc BleSecMngrPassKey(hc[i[1]],i[2])
  endif  
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if strcmp(tkn$,"defSave")==0 then
    //extract 1 (#INTsave# ) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,1)
    if rc != 0 then
      exitfunc rc
    endif
    exitfunc BleSecMngrBondReq(i[1])
  endif  
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if strcmp(tkn$,"start")==0 then
    //extract 2 (#INTconnHandle# #INTsave#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,2)
    if rc != 0 then
      exitfunc rc
    endif
    exitfunc BlePair(hc[i[1]], i[2])
  endif  
endfunc 5

//-------------------------------------------------------------------------
//#CMD#//  bond list
//#CMD#//  bond erase #HEXaddr14Bytes#
//#CMD#//  bond eraseall
//#CMD#//  bond persist #HEXaddr14Bytes#
//#CMD#//  bond istrusted #HEXaddr14Bytes# #INTasCentral#
//#CMD#//  bond istrustedx #HEXaddr14Bytes# #INTasCentral#   (also displays the total rolling)
//-------------------------------------------------------------------------
function _Bond() 
  dim keyInfo,tmp,nCount,idx
  tlen = ExtractStrToken(urtcmd$,tkn$)
  if tlen == 0 then
    exitfunc 5
  endif
  //---------------------------------------------------------
  if strcmp(tkn$,"list")==0 then
    nCount = SysInfo(2009) - 1
    for idx = 0 to nCount
      rc = BleBondMngrGetInfo(idx,s$[1],keyInfo)
      if rc != 0 then
        print "\n-- call to BleBondMngrGetInfo() failed with ";integer.h' rc
      else
        print "\n";strhexize$(s$[1]);"  "
                
        tmp=((keyInfo>>20) & 0x01) 
        if tmp==0 then
          print " -"
        else
          print " +"
        endif
        print "Rg"                
      endif
    next
    exitfunc 0
  endif
  //---------------------------------------------------------
  if strcmp(tkn$,"erase")==0 then
    //the next token has to be a mac address
    rc = ExtractAddrTokens(urtcmd$,1,1)
    if tlen == 0 then
      exitfunc 5
    endif
    rc = BleBondingEraseKey(s$[1])
    AssertResCode(rc,8200)
    exitfunc rc
  endif
  //---------------------------------------------------------
  if strcmp(tkn$,"eraseall")==0 then
    rc = BleBondingEraseAll()
    AssertResCode(rc,8210)
    exitfunc rc
  endif
  //---------------------------------------------------------
  if strcmp(tkn$,"persist")==0 then
    //the next token has to be a mac address
    rc = ExtractAddrTokens(urtcmd$,1,1)
    if tlen == 0 then
      exitfunc 5
    endif
    rc = BleBondingPersistKey(s$[1])
    AssertResCode(rc,8220)
    exitfunc rc
  endif
  //---------------------------------------------------------
  if strcmp(tkn$,"istrusted")==0 then
    exitfunc _IsTrusted(0)
  endif
  //---------------------------------------------------------
  if strcmp(tkn$,"istrustedx")==0 then
    exitfunc _IsTrusted(1)
  endif
endfunc 5

//-------------------------------------------------------------------------
//#CMD#//  misc addr2hndl #HEXaddr14Bytes#
//#CMD#//  misc hndl2addr #INTval#
//#CMD#//  misc sysinfo #INTformat# #INTid#    //INTformat: 0=dex, 1=Oct, 2=binary, 3=hex
//#CMD#//  misc sysinfo$ #INTid#
//#CMD#//  misc s$ clearall
//#CMD#//  misc s$ set #INTidx# #STRescapedvalue#
//#CMD#//  misc i  clearall
//#CMD#//  misc i  set #INTidx# #INTval#
//-------------------------------------------------------------------------
function _Misc()  
  dim ad$
  tlen = ExtractStrToken(urtcmd$,tkn$)
  if tlen == 0 then
    exitfunc 5
  endif
  //=================================================
  if strcmp(tkn$,"addr2hndl")==0 then
    tlen = ExtractStrToken(urtcmd$,tkn$)
    if tlen == 0 then
      exitfunc 5
    endif
    s$[1]=StrDehexize$(tkn$)
    if strlen(s$[1]) != 7 then
      exitfunc 5
    endif
    print "\n"
    rc = BleGetConnHandleFromAddr(s$[1],i[1])
    AssertResCode(rc,1680)
    if rc==0 then
      //then look through list
      print integer.h' i[1]
      exitfunc 0
    endif
    print "FFFFFFFF"
    exitfunc 0
  endif
  //=================================================
  if strcmp(tkn$,"hndl2addr")==0 then
    //extract 1 (#INTval#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,1)
    if rc != 0 then
      exitfunc rc
    endif
    print "\n"
    if (i[1]>0)&&(i[1]<=NUM_OF_CONNS) then
      rc=BleGetAddrFromConnHandle(hc[i[1]],ad$)
       AssertResCode(rc,1699)
      if rc==0 then
        print StrHexize$(ad$)
        exitfunc 0
      endif
    endif
    print "00000000000000"
    exitfunc 0
  endif
  //=================================================
  if strcmp(tkn$,"sysinfo")==0 then
    //extract 2 (#INTformat# #INTid#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,2)
    if rc != 0 then
      exitfunc rc
    endif
    rc=sysinfo(i[2])
    print "\n"
    select i[1]
    case 1 //octal
      print integer.o' rc
    case 2 //binary
      print integer.b' rc
    case 3 //hex
      print integer.h' rc
    case else  //decimal
      print rc
    endselect
    exitfunc 0
  endif
  //=================================================
  if strcmp(tkn$,"sysinfo$")==0 then
    //extract 1 (#INTid#) and store starting at i[1]
    rc = ExtractIntTokens(urtcmd$,1,1)
    if rc != 0 then
      exitfunc rc
    endif
    print "\n";sysinfo$(i[1])
    exitfunc 0
  endif
  //=================================================
  if strcmp(tkn$,"s$")==0 then
    tlen = ExtractStrToken(urtcmd$,tkn$)
    if tlen == 0 then
      exitfunc 5
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"clearall")==0 then
      exitfunc ClearS()
    endif  
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"set")==0 then
      //extract 1 (#INTidx#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      if (i[1] < 0) || (i[1] >= NUM_OF_S_PARAMS) then 
        exitfunc 6
      endif
      //extract 1 (#STRescapedvalue#) and store starting at s$[1]
      rc = ExtractStrTokens(urtcmd$,i[1],1)
      if rc != 0 then
        exitfunc rc
      endif
      StrDeEscape(s$[i[1]])
      exitfunc 0
    endif  
  endif
  //=================================================
  if strcmp(tkn$,"i")==0 then
    tlen = ExtractStrToken(urtcmd$,tkn$)
    if tlen == 0 then
      exitfunc 5
    endif
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"clearall")==0 then
      exitfunc ClearI()
    endif  
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"set")==0 then
      dim idx
      tlen = ExtractIntToken(urtcmd$,idx)
      if tlen == 0 then
        exitfunc 5
      endif
      if (idx < 0) || (idx >= NUM_OF_I_PARAMS) then 
        exitfunc 6
      endif
      tlen = ExtractIntToken(urtcmd$,i[idx])
      if tlen == 0 then
        exitfunc 5
      endif
      exitfunc 0
    endif  
  endif
endfunc 5

//==============================================================================
//==============================================================================
function OnUartCmd() as integer
  rc=1 //assume there is an error
  tlen = ExtractStrToken(urtcmd$,tkn$) //get first token
  if tlen == 0 then
    rc=0
  elseif tlen > 0 then
    
    if strcmp(tkn$,"advert")==0 then
      rc = _Advert()
      
    elseif strcmp(tkn$,"scan")==0 then
      rc = _Scan()
      
    elseif strcmp(tkn$,"connect")==0 then
      rc = _Connect()
      
    elseif strcmp(tkn$,"disconnect")==0 then
      rc = _Disconnect()
      
    elseif strcmp(tkn$,"pair")==0 then
      rc = _Pair()
    
    elseif strcmp(tkn$,"bond")==0 then
      rc = _Bond()
    
    elseif strcmp(tkn$,"txpower")==0 then
      rc = _TxPower()
      
    elseif strcmp(tkn$,"gattc")==0 then
      rc = _Gattc()
    
    elseif strcmp(tkn$,"gatts")==0 then
      rc = _Gatts()
    
    elseif strcmp(tkn$,"uuid")==0 then
      rc = _uuid()
    
    elseif strcmp(tkn$,"misc")==0 then
      rc = _misc()
    
    elseif (strcmp(tkn$,"exit")==0)||(strcmp(tkn$,"stop")==0) then
      //print "\nType..\nRESUME          to continue the application"
      //print "\n? VARNAME       to inspect a variable"    
      //print "\n= VARNAME VALUE to change a variable"    
      stop 
      rc=0
    
    endif
  endif
  // send a response back to the user
  UartRsp(rc)
endfunc 1

//******************************************************************************
// Handler definitions
//******************************************************************************

//==============================================================================
// This handler is called when data has arrived at the serial port
//==============================================================================
function HandlerUartRxCmd() as integer
  dim nMatch
  
  if urts < 0 then
    //uart parser is suspended
    exitfunc 1
  endif

  //check if CR has been received
  nMatch=UartReadMatch(stRsp$,13)
  if nMatch!=0 then
    //CR exists in the input buffer
    urtcmd$ = strsplitleft$(stRsp$,nMatch)
    exitfunc OnUartCmd()
  endif
endfunc 1

//==============================================================================
// This handler is called when data has arrived at the serial port
//==============================================================================
function HandlerUartRxVsp() as integer
  //just write to the VSP service
  if vsplen==0 then
    vsplen  = UartReadN(vdta$, VSP_MAX_CHARDATA_LEN )
    if vsplen > 0 then
      //can send to the VSP service in the peripheral
      rc=BleGattcWriteCmd(hcVsp,vspRxH,vdta$)
      //print vdta$      
      vdta$=""
    endif
  endif
endfunc 1

//==============================================================================
// This handler is called when there is a BLE message
//==============================================================================
function HandlerBleMsg(BYVAL nMsgId AS INTEGER, BYVAL nCtx AS INTEGER) as integer
  dim hz
  
  select nMsgId
  case BLE_EVBLEMSGID_CONNECT
    hz = AcqConnHandle(nCtx)
    conns = conns + 1
    print "\n --- Connect: (";integer.h' nCtx;") handle=";hz
    if hz == 0 then
      //Could not store the handle so drop the connection
      rc = BleDisconnect(nCtx)
      print " DROPPED"
    else
      //accepted so display connection parameters
      ShowConnParms(nCtx)
      //always assume most recent connection for VSP
      hcVsp = hc[hz]
    endif
  
  // See HandlerDisconnect below also
  case BLE_EVBLEMSGID_DISCONNECT
    print "\n --- EVBLEMSGID->DISCONNECT"

  case BLE_EVBLEMSGID_DISPLAY_PASSKEY
    print "\nDisplay Pairing Passkey 0x"; integer.h' nCtx

  case BLE_EVBLEMSGID_NEW_BOND
    print "\n +++ New Bond"

  case BLE_EVBLEMSGID_UPDATED_BOND
    print "\n +++ Updated Bond"

  case BLE_EVBLEMSGID_ENCRYPTED
    print "\n +++ Encrypted Connection"

  case BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER
    print "\n -- Conn to Bonded Peer  ";nCtx

  case BLE_EVBLEMSGID_AUTH_KEY_REQUEST
    print "\n +++ Auth Key Request, type= ";nCtx

  case BLE_EVBLEMSGID_CONN_PARMS_UPDATE
    ShowConnParms(nCtx)

  case BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL
    print "\n ??? Conn Parm Negotiation FAILED"

  case else
    print "\nUnknown Ble Msg "; nMsgId
  endselect
endfunc 1

//==============================================================================
// This handler is called when there is a EVDISCON message
//==============================================================================
function HandlerDisconnect(BYVAL nConnH AS INTEGER, BYVAL nReas AS INTEGER) as integer
    dim hz
    hz = RelConnHandle(nConnH)
    conns = conns - 1
    print "\n --- Disconnect: (";integer.h' nConnH;") handle=";hz;" reason=";nReas

endfunc 1

//==============================================================================
// This handler is called when there is an advert timeout
//==============================================================================
function HandlerBlrAdvTimOut() as integer
  print "\n\nAdverts timeout"
endfunc 1

//==============================================================================
// This handler is called when there is an advert report waiting to be read
//==============================================================================
function HandlerAdvRpt() as integer
  ReadAdvReports(advmax,advcnt)
endfunc 1

//==============================================================================
// This handler is called when there is a connection attempt timeout
//==============================================================================
function HandlerBlrConnTimOut() as integer
  print "\nConnection attempt stopped via timeout" 
endfunc 1

//==============================================================================
// This handler is called when there is a scan attempt timeout
//==============================================================================
function HandlerBlrScanTimOut() as integer
  print "\nScanning stopped via timeout, advert count = " ; advcnt
endfunc 1

//==============================================================================
// This handler is called when there is a scan attempt timeout
//==============================================================================
function HandlerFastPaged() as integer
  dim ad$,rsi
  rc = BleScanGetPagerAddr(ad$,rsi)
  if rc != 0 then
    print "\n\nBleScanGetPagerAddr() failed "
  endif
  print "\nFast Paged by : "; strhexize$(ad$); " rssi = ";rsi
  
  // stop scanning
  rc=BleScanStop()
endfunc 1

//==============================================================================
//==============================================================================
function HandlerPrimSvc(hConn,hUuid,hStart,hEnd) as integer
  select gcState
  case 0
    print "\nEVDISCPRIMSVC("
    print "hConn=";integer.h' hConn;",hUuid=";integer.h' hUuid
    print ",hStart=";hStart;",hEnd=";hEnd;")"
    
  case 1  //tablemapping
    if hStart!=0 then
      // S: hStart,(hEnd),hUuid
      print "\nS:";hStart;" ,(";hEnd;") ,";integer.h' hUuid
      // and get all characteristics of this service
      rc=BleDiscCharFirst(hConn,0,hStart,hEnd)
      if rc!=0 then
        TerminateTableMap(rc)
      endif
    else
      //reached end of remote gatt table
      TerminateTableMap(0)
    endif
    
  case else
  endselect
endfunc 1

//==============================================================================
//==============================================================================
function HandlerCharDisc(hConn,hUuid,cProp,hVal,hiUuid) as integer
  select gcState
  case 0
    print "\nEVDISCCHAR("
    print "hConn=";integer.h' hConn;",hCharUuid=";integer.h' hUuid;",hIncUuid=";hiUuid
    print ",hVal=";hVal;",Props=";integer.h' cProp;")"
    
  case 1  //tablemapping
    if hVal!=0 then
      // C: hVal,cProp,hUuid,hiUuid
      print "\n C:";hVal;" ,";integer.h' cProp;" ,";integer.h' hUuid;" ,";hiUuid
      // and get all descriptors of this characteristics
      rc=BleDiscDescFirst(hConn,0,hVal)
      if rc!=0 then
        TerminateTableMap(rc)
      endif
    else
      //no more chars in this service, so go for next service
      rc = BleDiscServiceNext(hConn)
      if rc!=0 then
        TerminateTableMap(rc)
      endif
    endif
    
  case else
  endselect
endfunc 1

//==============================================================================
//==============================================================================
function HandlerDescDisc(hConn,hUuid,hDesc) as integer
  select gcState
  case 0
    print "\nEVDISCDESC("
    print "hConn=";integer.h' hConn;",hDescUuid=";integer.h' hUuid;",hDesc=";hDesc;")"
    
  case 1  //tablemapping
    if hDesc!=0 then
      // D: hDesc,hUuid
      print "\n  D:";hDesc;" ,";integer.h' hUuid
    endif
    // and get all descriptors of this characteristics
    rc=BleDiscDescNext(hConn)
    if rc!=0 then
      //no more descc in this char, so go for next char
      rc = BleDiscCharNext(hConn)
      if rc!=0 then
        rc = BleDiscServiceNext(hConn)
        if rc!=0 then
          TerminateTableMap(rc)
        endif
      endif
    endif
    
  case else
  endselect
endfunc 1

//==============================================================================
//==============================================================================
function HandlerFindChar(hConn,cProp,hVal,hiUuid) as integer
  print "\nEVFINDCHAR("
  print "hConn=";integer.h' hConn;",hIncUuid=";integer.h' hiUuid
  print ",hVal=";hVal;",Props=";integer.h' cProp;")"
endfunc 1

//==============================================================================
//==============================================================================
function HandlerFindDesc(hConn,hDesc) as integer
  print "\nEVFINDDESC("
  print "hConn=";integer.h' hConn;",hDesc=";hDesc;")"
endfunc 1

//==============================================================================
//==============================================================================
function HandlerAttrWrite(hConn,aHndl,nSts) as integer
    print "\nEVATTRWRITE(hConn=";integer.h' hConn;",handle=";aHndl;",status=";nSts;")"
endfunc 1

//==============================================================================
//==============================================================================
function HandlerAttrRead(hConn,hAttr,nSts) as integer
  dim a$,ofst  
  print "\nEVATTRREAD(hConn=";hConn;",handle=";hAttr;",status=";nSts;")"
  if nSts == 0 then
    rc = BleGattcReadData(hConn,hAttr,ofst,a$)
    if rc==0 then
      print "\n >BleGattcReadData(data=";StrHexize$(a$);",offset=";ofst;")"
      print "\n                  (data=";StrEscape$(a$);")"
    endif
  endif        
endfunc 1

'//==============================================================================
'// This handler is called when there is a EVCHARVAL message
'//==============================================================================
function HandlerCharVal(BYVAL hChar AS INTEGER, byval offset, byval len) as integer
  print "\nEVCHARVAL(hChar=";integer.h' hChar;",offset=";offset;",len=";len;")"
endfunc 1

'//==============================================================================
'// This handler is called when there is a CHARHVC message
'//==============================================================================
function HandlerCharHvc(BYVAL hChar AS INTEGER) as integer
    print "\nEVCHARHVC(hChar=";integer.h' hChar;")"
endfunc 1

'//==============================================================================
'// This handler is called when there is a CHARCCCD message
'//==============================================================================
function HandlerCharCccd(BYVAL hChar AS INTEGER, BYVAL nVal AS INTEGER) as integer
  print "\nEVCHARCCCD(hChar=";integer.h' hChar;",value=";nVal;")"
endfunc 1

'//==============================================================================
'// This handler is called when there is a CHARSCCD message
'//==============================================================================
function HandlerCharSccd(BYVAL hChar AS INTEGER, BYVAL nVal AS INTEGER) as integer
  print "\nEVCHARSCCD(hChar=";integer.h' hChar;",value=";nVal;")"
endfunc 1

'//==============================================================================
'// This handler is called when there is a CHARDESC message
'//==============================================================================
function HandlerCharDesc(BYVAL hChar AS INTEGER, BYVAL hDesc AS INTEGER) as integer
  dim duid,a$,rc
  print "\nEVCHARDESC(hChar=";integer.h' hChar;",hDesc=";integer.h' hDesc;")"    

  //read the descriptor data
  rc = BleCharDescRead(hChar,hDesc,0,512,duid,a$)
  print "\n > BleCharDescRead (0,512) = "
  print "hUuid=";integer.h' duid;",data=";StrHexize$(a$);",len=";StrLen(a$);") returned ";integer.h' rc
endfunc 1

//==============================================================================
//==============================================================================
function HandlerAttrNtfyCmd() as integer
  dim hConn,hAttr,att$,dscd
  print "\nEVATTRNOTIFY()"
  do
    rc=BleGattcNotifyRead(hConn,hAttr,att$,dscd)
    if rc==0 then
      print "\n >BleGattcNotifyRead("
      print "hConn=";integer.h' hConn;",handle=";hAttr;",Dumped=";dscd
      print ",data=";StrHexize$(att$);")"
    endif
  dowhile rc==0
endfunc 1

//==============================================================================
//==============================================================================
function HandlerAttrNtfyVsp() as integer
  dim hConn,hAttr,att$,dscd
  //print "\nEVATTRNOTIFY(vsp)"
  do
    rc=BleGattcNotifyRead(hConn,hAttr,att$,dscd)
    if rc==0 then
      if vspTxH == hAttr then
        print att$
      else
        //print "\n >BleGattcNotifyRead("
        print "hConn=";integer.h' hConn;",handle=";hAttr;",Dumped=";dscd
        print ",data=";StrHexize$(att$);")"
      endif
    endif
  dowhile rc==0
endfunc 1

'//==============================================================================
'// When WriteCmd or a Notify has been sent and baseband confirmed
'//==============================================================================
function HandlerNotifyBufCmd() as integer
  print "\nEVNOTIFYBUF"
endfunc 1

'//==============================================================================
'// When WriteCmd or a Notify has been sent and baseband confirmed
'//==============================================================================
function HandlerNotifyBufVsp() as integer
  vsplen=0
endfunc HandlerUartRxVsp()

'//==============================================================================
'// Called when the state of sio28 changes. Connected to DTR output of PC
'//==============================================================================
function HandlerSio28() as integer
  if GpioRead(28) then
    //DTR Deasserted so NOT command mode
    if conns>0 then
      OnEvent  EVUARTRX       call HandlerUartRxVsp    
      Onevent  EVNOTIFYBUF    call HandlerNotifyBufVsp
      OnEvent  EVATTRNOTIFY   call HandlerAttrNtfyVsp
    endif
  else
    //DTR Deasserted so command mode
    OnEvent  EVUARTRX       call HandlerUartRxCmd    
    Onevent  EVNOTIFYBUF    call HandlerNotifyBufCmd
    OnEvent  EVATTRNOTIFY   call HandlerAttrNtfyCmd
  endif
endfunc 1


//******************************************************************************
//******************************************************************************
// Equivalent to main() in C
//******************************************************************************

//------------------------------------------------------------------------------
// Enable synchronous event handlers
//------------------------------------------------------------------------------
OnEvent  EVUARTRX                 call HandlerUartRxCmd
Onevent  EVNOTIFYBUF              call HandlerNotifyBufCmd
OnEvent  EVATTRNOTIFY             call HandlerAttrNtfyCmd

OnEvent  EVDISCON                 call HandlerDisconnect
OnEvent  EVBLE_ADV_TIMEOUT        call HandlerBlrAdvTimOut
OnEvent  EVBLEMSG                 call HandlerBleMsg
OnEvent  EVBLE_CONN_TIMEOUT       call HandlerBlrConnTimOut
OnEvent  EVBLE_SCAN_TIMEOUT       call HandlerBlrScanTimOut
OnEvent  EVBLE_ADV_REPORT         call HandlerAdvRpt
OnEvent  EVBLE_FAST_PAGED         call HandlerFastPaged

OnEvent  EVDISCPRIMSVC            call HandlerPrimSvc
OnEvent  EVDISCCHAR               call HandlerCharDisc
OnEvent  EVDISCDESC               call HandlerDescDisc
OnEvent  EVFINDCHAR               call HandlerFindChar
OnEvent  EVFINDDESC               call HandlerFindDesc
OnEvent  EVATTRWRITE              call HandlerAttrWrite
OnEvent  EVATTRREAD               call HandlerAttrRead

OnEvent  EVCHARVAL                call HandlerCharVal
OnEvent  EVCHARHVC                call HandlerCharHvc
OnEvent  EVCHARCCCD               call HandlerCharCccd
OnEvent  EVCHARSCCD               call HandlerCharSccd
OnEvent  EVCHARDESC               call HandlerCharDesc

OnEvent  EVGPIOCHAN0              call HandlerSio28

//------------------------------------------------------------------------------
// Initialise Services and then wait for events
//------------------------------------------------------------------------------

//==============================================================================
//==============================================================================
sub Initialise()
  InitConnHandles()
endsub

//==============================================================================
//==============================================================================
sub Startup()
  //Ensure we can detect changes in nAutorun (SIO28)
  rc=GpioBindEvent(0,28,2)
  AssertResCode(rc,100)
endsub


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
Initialise()
Startup()

//Send user prompt for uart based command interface
print "\n\r";BleGetDeviceName$();"\n\r"
//Send an OK response
UartRsp(0)

//------------------------------------------------------------------------------
// Wait for a synchronous event.
// An application can have multiple <WaitEvent> statements
//------------------------------------------------------------------------------
WaitEvent


